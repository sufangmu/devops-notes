## 一、`malloc`函数

`malloc`是memory allocate的缩写

```c
#include <stdio.h>
#include <malloc.h>
int main(void)
{
    int * p = (int *)malloc(4);
    return 0;
}
```

1. 要使用`malloc()`函数，必须添加`malloc.h`这个头文件
2. `malloc()`函数只有一个形参，并且形参时整型
3. 4表示请求系统为本程序分配4个字节
4. `malloc()`函数只能返回第一个字节的地址

## 二、动态内存分配的使用

```c
int *p = (int *)malloc(len);
```

1. 本语句分配了两块内存：一块内存是动态分配的，占len个字节；另一个是静态分配的，并且这块静态内存是p变量本身所占的字节，占4个字节
2. malloc只有一个int型的形参，表示要求系统分配的字节数
3. malloc函数的功能是请求系统len个字节的内存空间，如果请求分配成功，则返回第一个字节的地址。如果分配不成功，则返回NULL。
4. malloch函数能且只能返回第一个字节的地址，所以需要把这个无任何实际意义的第一个字节的地址转化为一个有实际意义的地址，因此，malloc前面必须加`<数据类型> *`表示把这个无意义的第一个字节的地址转化为相应类型的地址。如`int *p = (int *)malloc(100);`的含义为：将系统分配好的100个字节的第一个字节的地址转化为`int *`型的地址，更准确的说是吧第一个字节的地址转为4个字节的地址，这样p就指向了第一个的4个字节，p+1就指向了第2个4个字节，p+i就指向了第i+1个的4个字节。p[0]就是第一个元素，p[i]就是i+1个元素。

## 3. freep

```c
freep(p);
```

表示把p所指向的内存给释放掉。

p本身的内存是静态的，不能由程序员手动释放，p本身的内存只能在p变量所在的函数运行终止时由系统自动释放。

## 4. 静态内存和动态内存的比较

1. 静态内存是有系统自动分配的，由系统自动释放；静态内存是在栈分配的。
2. 动态内存是由程序员手动分配的，手动释放；动态内存是在堆分配的。

## 5. 跨函数使用内存

静态内存不能跨函数使用：

1. 静态内存在函数执行期间可以被其他函数使用
2. 静态内存在函数执行完毕之后就不能被其他函数使用了

```c
#include <stdio.h>

void f(int **q)  // q是指针变量。无论q是什么类型的指针变量，都只占4个字节
{
    int i = 5;
    // *q等价于p
    *q = &i;  // p = &i;
}

int main(void)
{
    int *p;
    f(&p);
    printf("%d\n", *p); // 5  // 本语句语法没有错误，但是逻辑错误
    return 0;
}
```

动态内存可以跨函数使用：

1. 动态内存在函数执行完毕之后仍可以被其他函数使用

```c
#include <stdio.h>
#include <malloc.h>
void f(int **q)  // q是指针变量。无论q是什么类型的指针变量，都只占4个字节
{
    *q = (int *)malloc(sizeof(int));
    **q = 5;
}

int main(void)
{
    int *p;
    f(&p);
    printf("%d\n", *p);
    return 0;
}
```

