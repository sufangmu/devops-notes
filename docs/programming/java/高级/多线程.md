## 一、线程的创建和使用

### 1. 方式一：继承Thread类

```java
public class ThreadTest {
    public static void main(String[] args) {
        // 3. 创建Thread类子类的对象
        MyThread t = new MyThread();
        // 4. 通过此对象调用start(): ①启动当前线程；②调用当前线程的run()
        t.start();
        // 其他代码仍然在main线程中执行
    }
}

// 1. 创建继承于Thread类的子类
class MyThread extends Thread {
    // 2. 重写Thread类的run方法
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
            }
        }
    }
}
```

### 2. 方式二：实现`Runnable`接口

```java
package com.example.www;

public class ThreadTest {
    public static void main(String[] args) {
        // 3. 创建实现类的对象
        MyThread myThread = new MyThread();
        // 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
        Thread t = new Thread(myThread);
        // 5. 通过Thread类的对象调用start()
        t.start();
    }
}

// 1. 创建一个实现了Runnable接口的类
class MyThread implements Runnable {
    // 2. 实现类去实现Runnable中的抽象方法run()
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
            }
        }
    }
}
```

开发中优先使用这种方式

1. 实现的方法没有类的单继承性的局限性
2. 实现的方法更适合来处理有共享数据的情况

### 5. 线程的常用方法

```java
package com.example.www;

public class ThreadMethodTest {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.setName("Thread-zero"); // 自定义线程名
        t.start();
        // 判断当前进程是否存活
        System.out.println(t.isAlive()); // true
        for (int i = 0; i < 100; i++) {
            if (i % 2 != 0) {
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
            if (i == 20) {
                try {
                    // 当前线程进入阻塞状态，直到线程t完全执行完以后
                    t.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class MyThread extends Thread {
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                // currentThread() 静态方法，返回执行当前代码的线程
                // getName() 获取当前线程名
                System.out.println(Thread.currentThread().getName() + ":" + i); // Thread-zero 默认是：Thread-0
            }
//            if (i % 20 == 0) {
//                yield(); // 释放当前CPU的执行权
//            }
        }
    }
}
```

### 6. 线程优先级

```java
// MIN_PRIORITY = 1
// NORM_PRIORITY = 5
// MAX_PRIORITY = 10
public class ThreadMethodTest {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        // 设置线程的优先级
        t.setPriority(7);
        t.start();
        // 获取线程的优先级
        System.out.println(t.getPriority()); // 7
    }
}

class MyThread extends Thread {
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
            }
        }
    }
}
```

## 二、线程的生命周期



## 三、线程同步

买票过程中出现了重票和错票 --> 出现了线程安全问题

在Java中通过同步机制来解决线程的安全问题

操作同步代码时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低。

### 1. 方法一：同步代码块

#### 1.1 同步代码块处理实现`Runnable`的线程安全问题

```java
/*
synchronized(同步监视器){ // 同步监视器：俗称锁，任何一个类的对象都可以充当锁
     需要被同步的代码 // 操作共享数据的代码
}
*/
public class TicketWindowTest {
    public static void main(String[] args) {
        Window window = new Window();
        Thread t1 = new Thread(window);
        Thread t2 = new Thread(window);
        Thread t3 = new Thread(window);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}


class Window implements Runnable {
    private int ticket = 100;
    // new 一个对象充当锁
    // Object obj = new Object(); // 多个线程必须要公用一把锁


    public void run() {
        while (true) {
            // synchronized(obj) {
            synchronized(this) { // 用当前对象充当锁，此时的this是唯一的Window对象
                if (ticket > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + ":买票，票号为：" + ticket);
                    ticket--;
                } else {
                    break;
                }
            }
        }
    }
}
```

1.1 同步代码块处理继承Thread类方式的线程安全问题

```java
public class TicketWindowTest {
    public static void main(String[] args) {
        Window t1 = new Window();
        Window t2 = new Window();
        Window t3 = new Window();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

class Window extends Thread {
    private static int ticket = 100;
//    private static Object obj = new Object();
    public void run() {
        while (true){
//            synchronized (obj) {
            synchronized (Window.class) { // Window类只会加载一次，所以可以使用当前类充当锁
                if (ticket > 0) {
                    try {
                        Thread.sleep(100); // 添加延时，增加出错概率
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(getName() + ":买票，票号为：" + ticket);
                    ticket--;
                } else {
                    break;
                }
            }
        }
    }
}
```



### 2. 方法一：同步方法



## 四、线程通信

