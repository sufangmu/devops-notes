# 函数

## 1. 函数的作用

1. 代码重用，减少代码冗余
2. 流程分解

## 2. 函数分类

1. 内置函数
2. 自定义函数

## 3. 函数的定义

```python
def name(arg):
    pass
    return value
```

## 4. 函数的参数

### 4.1 位置参数

```python
def add(x,y):
    print (x+y)
add(3,5)
```

### 4.2 默认参数

```python
def student(name, age=21):
    print('Name:',name)
    print('Age:',age)
```

### 4.3 可变参数

```python
# 传入的参数个数是可变的，可以是 1 个、2 个到任意个，还可以是 0 个
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
print(calc(1, 2, 3))
```

### 4.4 关键字参数

```python
# 关键字参数在函数内部自动组装为一个 dict
def student(name, age, **kwargs):
    print('Name:', name)
    print('Age:', age)
    print('other:', kwargs)

student('张三', 13, sex='boy')
###运行结果###
Name: 张三
Age: 13
other: {'sex': 'boy'}
```

### 4.5 命名关键字参数

```python
# *后面的参数被视为命名关键字参数,只接收 city 和 job 作为关键字参数
def person(name, age, *, city, job):
    print(name, age, city, job)

person('张三', 18, city="xi'an", job='IT')
```

### 4.6 组合参数

参数顺序：必选参数、默认参数、可变参数/命名关键字参数和关键字参数

## 5. 函数的多态

函数中x,y的意义完全取决于x和y的对象类型

```python
def add(x,y):
    print (x+y)

add(3,5)  # 加法
add('hello','world') # 字符串拼接
```

## 6. 嵌套函数

```python
def bar():
    def foo():
        print("hello world")
    foo()
bar()
```

## 7. 作用域法则LEGB

1. L-Local(function)；函数内的名字空间
2. E-Enclosing function locals；外部嵌套函数的名字空间(例如closure)
3. G-Global(module)；函数定义所在模块（文件）的名字空间
4. B-Builtin(Python)；Python内置模块的名字空间

## 8. global语句

```python
x = 88
def bar():
    global x
    x = 99
bar()
print (x)
```

## 9. nonlocal

用于嵌套函数中，只作用于外层函数的作用域中，而不是全局

```python
def bar():
    x = 1
    def foo():
        nonlocal x
        x += 1
    foo()
    print(x)

bar()
```

## 10. 闭包(closure)

在一个内部函数对在外部的作用的作用域进行一个引用，那么内部函数就是一个闭包

```python
>>> def maker(N):
...     def action(X):    #一个内部函数
...         return X ** N  #N为上级函数的一个变量
...     return action
...
>>> f = maker(2)
>>> f
<function maker.<locals>.action at 0x000002C47A1E2A60>
>>> f(3)
```

闭包的三个特点：

1. 闭包函数必须有内嵌函数
2. 内嵌函数需要引用该嵌套函数上一级namespace中的变量
3. 闭包函数必须返回内嵌函数

## 11. 函数的返回值

### 11.1 默认返回None

```python
>>> def bar():
...     print ("hello")
...
>>> f = bar()
hello
>>> print(f)
None
```

### 11.2  指定返回值

```python
>>> def bar():
...     print("hello")
...     return 1
...
>>> f = bar()
hello
>>> print(f)
```

### 11.3  返回计算结果

```python
>>> def bar(x,y):
...     return x + y
...
>>> f = bar(1,2)
>>> print(f)
```

### 11.4  结束函数

```python
>>> def bar():
...     print("hello")
...     return 1
...     print("world")
>>> bar()
hello
```

### 11.5 返回元组

```python
>>> def bar(x,y):
...     return x,y
...
>>> bar(1,2)
(1, 2)
```

return的作用

1. 结束函数
2. 将一个结果对象传回给调用者

## 12. 三元函数

```python
>>> print('hello') if True else False
hello
```

## 13. 高阶函数

### 13.1 变量名可以指向函数

```python
>>> abs(-10)
>>> f = abs
>>> f(-10)
```

### 13.2 函数名可以作为其他函数的参数

```python
>>> def bar(x,y,f):
...     return f(x)+f(y)
...
>>> bar(-5,-3,abs)
```

### 13.3 函数名可以作为返回值

```python
>>> def bar():
...     def foo():
...         return "hello"
...     return foo
...
>>> bar()
<function bar.<locals>.foo at 0x00000194EED32A60>
```

## 14. 装饰器（Decorator）

开放封闭原则：

​开放：对代码的扩展开放
​封闭：对代码的修改封闭

装饰器完全遵循开放封闭原则。在不改变原函数的代码以及调用方式的前提下，为其增加代码功能。

### 14.1 在代码运行期间增加功能

```python
def hello():
    print("hello")
# 函数名可以作为其他函数的参数
def show_time(func):
    print("------------")
    func()
    print("------------")

show_time(hello)
# 或者如下
# hello = show_time(hello)
# hello
# 但调用方式还是发生了改变
```

### 14.2 保留函数调用方式

如果把一个函数名赋值给hello，hello()就可以执行函数了，关键问题是如何让show_time(hello)作为函数名赋值给hello

想想高阶函数中函数名可以作为返回值返回的特性
可以把上述的函数改为如下

```python
def hello():
    print("hello")

def show_time(func):
    def inner():
        print("------------")
        func()
        print("------------")
    return inner    #此时如果调用show_time，返回的就是inner函数的函数名

hello=show_time(hello) #将inner函数赋值给hello
hello()  #实际执行的是inner函数
```

### 14.3 语法糖`@func`

在python中hello=show_time(hello)可以写为@show_time，如下

```python
def show_time(func):
    def inner():
        print("------------")
        func()
        print("------------")
    return inner

@show_time # hello=show_time(hello)
def hello():
    print("hello")
hello()
```

### 14.4 装饰器的参数

```python
def show_time(func):
    def inner(name):
        print("------------")
        func(name)
        print("------------")
    return inner

@show_time
def hello(name):
    print("hello",name)

hello('Bob')
```

### 14.5 函数中嵌套装饰器

```python
import time
def logger(flag=''):
    def show_time(func):
        def inner(*args,**kwargs):
            start = time.time()
            time.sleep(1)
            func(*args,**kwargs)
            end = time.time()
            print('running time:',end - start)
            if flag == 'true':
                print('this is loggger')
		return inner
	return show_time

@logger('true')
def foo(*args,**kwargs):
    sums = 0
    for i in args:
        sums += i
    print(sums)

@logger()
def bar():
    print('bar..')

foo(1,2,3)
bar()
```

### 14.6 原函数名称的问题

`functools.wraps`的作用

```python
def show_time(func):
    def inner(name):
        print("------------")
        func(name)
        print("------------")
    return inner

@show_time
def hello(name):
    print("hello",name)

print(hello.__name__)
---运行结果---
>>inner
```

源函数的名称变成了inner，不是原来的hello,通过引入wraps解决这个问题
改进如下：

```python
from functools import wraps

def show_time(func):
    @wraps(func)
    def inner(name):
        print("------------")
        func(name)
        print("------------")
    return inner

@show_time
def hello(name):
    print("hello",name)

print(hello.__name__)
---运行结果---
>>hello
```

### 14.7 装饰器实例

```python
import sys
from functools import wraps

USERNAME, PASSWORD = 'root','123'
no_login = True

def login(func):
    @wraps(func)
    def inner(*args,**kwargs):
        global no_login
        if no_login:
            print('您还没有登录，请登录---')
            username = input('username:').strip()
            password = input('password:').strip()
            if USERNAME == username and PASSWORD == password:
                no_login = False
            else:
                print('user or password is wrong !')
                sys.exit()
        func(*args, **kwargs)
    return inner

@login
def home():
    print('恭喜来到京东主页')
@login
def phone():
    print('这里是手机专卖')
@login
def book():
    print('这里是图书商店')

main = """
1.home
2.phone
3.book
请选择要进入的主页
"""
while True:
    print(main)
    choice = input(">>:").strip()
    if  choice == '1':
        home()
    elif choice == '2':
        phone()
    elif choice == '3':
        book()
    else:
        sys.exit()
```

### 14.7 标准版装饰器

```python
def wrapper(func):
    def inner(*args, **kwargs):
        ret = func(*args, **kwargs)
        return ret
    return inner
```

## 15. 匿名函数

`lambda 形参:返回值`

```python
>>> f = lambda a,b:a+b
>>> f(1,2)
3
```





总结：装饰器三要素：LEGB、高阶函数、闭包

